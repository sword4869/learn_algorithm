- [1. 重要](#1-重要)
  - [1.1. 基础版：ij都查](#11-基础版ij都查)
  - [1.2. Leftmost 与 Rightmost的标准版](#12-leftmost-与-rightmost的标准版)
  - [1.3. Leftmost 与 Rightmost 的替身版](#13-leftmost-与-rightmost-的替身版)
  - [1.4. 递归版](#14-递归版)
- [2. 其他](#2-其他)
  - [2.1. 改动版：查i不查j](#21-改动版查i不查j)
  - [2.2. 平衡版：查i不查j的平衡](#22-平衡版查i不查j的平衡)

---
## 1. 重要

target < a[m] < target，target在两边。

1. 基础版和改动版：区别就是**左闭右闭**、左闭右开。

     - **j = n -1** , j = n
     - **while(i<=j)**, while(i<j)
     - **j = m- 1**, j = m

2. 基础版的复杂度

    时间复杂度
    * 最坏情况：$O(\log n)$
    * 最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$
    
    空间复杂度
    * 需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$ 

3. leftmost和rightmost的标准版：找不到返回-1

    - leftmost: 找到了往左移， j = m - 1
    - rightmost: 找到了往右移， i = m + 1
4. leftmost和rightmost的替身版：找不到返回替身

    - leftmost：大于等于的最左 `target <= a[m]`, i
    - rightmost：小于等于的最右 `a[m] <= target`，i-1

### 1.1. 基础版：ij都查 


```java
/**
 * <h3>二分查找基础版</h3>
 * @return <p>找到则返回索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchBasic(int[] a, int target) {
    int i = 0, j = a.length - 1;    // ij都查 
    // 元素在最左边 L 次，  元素在最右边 2*L 次
    while (i <= j) {                // [i,j] 范围内有东西
        int m = (i + j) >>> 1;
        if (target < a[m]) {         // 目标在左边
            j = m - 1;
        } else if (a[m] < target) { // 目标在右边
            i = m + 1;
        } else {                    // 找到了
            return m;
        }
    }
    return -1;
    // 返回将会被按顺序插入的位置。
    //      return i;         直接写法
    //      return -(i + 1);  java底层写法
}
```

### 1.2. Leftmost 与 Rightmost的标准版

返回的是最左侧的重复元素 / 返回的是最右侧的重复元素，没找到则返回-1.

leftmost：本来中间索引m处找到了，但是还往左找（移动j向左 `j = m - 1`）
  
<details>
<summary>过程</summary>

- 找18
    ```java
           m
           i   j  
    value: 18 18        找到了，记录
           
                i
            j
    value:      18 18 
    ```
- 找19
    ```java
           m
           i   j  
    value: 18 19 

                m
                i
                j
    value: 18  19       找到了，记录
    
                i
            j
    value: 18  19
    ```
    ```java
           i   m  j  
    value: 18 19 20     找到了，记录

            m
            i
            j
    value: 18 19  
    
               i
            j
    value: 18 19
    ```
    
</details>

```java
/**
 * <h3>二分查找 Leftmost </h3>
 * @return <p>找到则返回最靠左索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchLeftmost(int[] a, int target) {
    int i = 0, j = a.length - 1;
    int candidate = -1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            candidate = m; // 记录候选位置
            j = m - 1;     // 继续向左
        }
    }
    return candidate;
}
```
```java
/**
 * <h3>二分查找 Rightmost </h3>
 * @return <p>找到则返回最靠右索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchRightmost(int[] a, int target) {
    int i = 0, j = a.length - 1;
    int candidate = -1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            candidate = m; // 记录候选位置
            i = m + 1;	   // 继续向右
        }
    }
    return candidate;
}
```
### 1.3. Leftmost 与 Rightmost 的替身版

对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值，索引。

1. 简化：不用记录`candidate`，则直接去掉`candidate = m; // 记录候选位置`这一行。剩下`i = m + 1;`可以合并到上面的if-else中。
2. return 返回的含义变化：leftmost 找到大于等于目标的最左元素 `return i`，rightmost 找到小于等于目标的最右元素 `return i-1`

```java
/**
 * <h3>二分查找 Leftmost有用版 </h3>
 * @return <p>找到大于等于目标的最左元素的索引</p>
 */
public static int binarySearchLeftmostUseful(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target <= a[m]) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return i;
}

/**
 * <h3>二分查找 Rightmost有用版 </h3>
 * @return <p>找到小于等于目标的最右元素的索引</p>
 */
public static int binarySearchRightmostUseful(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else {
            i = m + 1;
        }
    }
    return i - 1;
}
```

<details>
<summary>过程</summary>

```java
// leftmost：找到大于等于目标的最左元素的索引

找 18
        j  i
value: 12 18 18

找 15
        j  i
value: 12 18 18
```

```java
// rightmost：找到小于等于目标的最右元素的索引
// PS: 如果返回i，那就是找到大于目标的最左元素


找 18
              j  i
value: 12 18 18 23

找 19
              j  i
value: 12 18 18 23
```

</details>

### 1.4. 递归版

拆解 while 循环。

```java
/**
 * <h3>二分查找 递归版 </h3>
 * @return <p>找到则返回索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchRecursion(int[] a, int target){
    return recursion(a, target, 0, a.length - 1);
}

public static int recursion(int[] a, int target, int i, int j){
    if(i > j){
        return -1;
        // return i;
    }

    int m = (i + j) >>> 1;

    if (target < a[m]){
        return recursion(a, target, i, m - 1);
    }else if(a[m] < target){
        return recursion(a, target, m + 1, j);
    }else{
        return m;
    }
}
```
## 2. 其他

### 2.1. 改动版：查i不查j

```java
/**
 * <h3>二分查找改动版</h3>
 * @return <p>找到则返回索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchAlternative(int[] a, int target) {
    int i = 0, j = a.length;     // 第一处
    while (i < j) {              // 第二处
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m;               // 第三处
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```

i所在的元素都被查，j则不查（j是右边界，左边的才会被查），则
- 首元素被查，尾元素的next边界。`int i = 0, j = a.length;`

    ```java
           i                    j
    value: 2 12 18 23 45 54 65
    ```
- 中间元素m：因为i所在的元素都被查，`i=m+1`；而j所在的不查，左边的才要被查，所以就放在已经比较过的中间元素m处，`j=m;`
- 临界条件：`while (i < j)`

    ```
    //最后一轮
    刚好要查12的情况，那么直接return
            m         
            i  j  
    value: 12  23 
    index:  3  4  

    还不是，则i右移或j移动到m处就这样，j所在的元素不查，那么就该退出 i<j 没有等于
            i  
            j  
    value: 12  
    index:  3  
    ```

### 2.2. 平衡版：查i不查j的平衡

```java
/**
 * <h3>二分查找平衡版</h3>
 * @return <p>找到则返回索引</p>
 * <p>找不到返回 -1</p>
 */
public static int binarySearchBalance(int[] a, int target) {
    int i = 0, j = a.length;
    while (1 < j - i) {         // 范围内待查找的元素个数 > 1 时
        int m = (i + j) >>> 1;
        if (target < a[m]) {    // 目标在左边
            j = m;
        } else {                // 目标在 m 或右边
            i = m;
        }
    }
    if (a[i] == target){
        return i;
    } else {
        return -1;
    }
}
```
> 原理

不奢望循环内通过 m 找出目标, 缩小区间直至剩 1 个, 剩下的这个可能就是要找的。

将判断相等的操作移动到外面，else就表示大于等于的情况（target在中间索引m的位置或右边），而i索引的位置要被查，就`i=m`；
```java
       i                    j
value: 2 12 18 23 45 54 65


// 退出条件：i和j相邻，确定了唯一一个元素。
            i   j
value: 2 12 18 23 45 54 65
```

> 性能

- 三分支改为二分支, 循环内的平均比较次数减少了（原本在target在中间索引右边的话，要比较两次；现在只比较一次）。
- 但是如果待查找元素恰好在数组中央，就不像原来只需要循环一次，而是要循环到只剩一个元素。
- 时间复杂度就没有最好最坏，都是查到只剩一个元素： $\Theta(log(n))$

