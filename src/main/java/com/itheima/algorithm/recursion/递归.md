- [1. 前后位置](#1-前后位置)
- [2. 类的成员变量什么都可以干](#2-类的成员变量什么都可以干)
  - [2.1. 传递不变的参数](#21-传递不变的参数)
  - [2.2. 返回值](#22-返回值)
- [3. 循环变递归](#3-循环变递归)
- [4. 记忆数组](#4-记忆数组)
- [多路递归](#多路递归)
- [多路递归→回溯](#多路递归回溯)

---

## 1. 前后位置
```java
void f(Node node) {
    // 临界条件
    if(node == null) {
        return;
    }

    // 递归前的操作：顺序
    println("before:" + node.value)
    
    f(node.next);

    // 递归前的操作：倒序
    println("after:" + node.value)
}
```
![alt text](../../../../../../../images/image-69.png)
```java
// 1 -> 2 -> 3 -> null  f(1)

void f(Node node = 1) {
    println("before:" + node.value) // 1
    void f(Node node = 2) {
        println("before:" + node.value) // 2
        void f(Node node = 3) {
            println("before:" + node.value) // 3
            void f(Node node = null) {
                if(node == null) {
                    return;
                }
            }
            println("after:" + node.value) // 3
        }
        println("after:" + node.value) // 2
    }
    println("after:" + node.value) // 1
}

// 3 -> 2 -> 1 -> null  f(3)

void f(Node node = 3) {
    println("before:" + node.value) // 3
    void f(Node node = 2) {
        println("before:" + node.value) // 2
        void f(Node node = 1) {
            println("before:" + node.value) // 1
            void f(Node node = null) {
                if(node == null) {
                    return;
                }
            }
            println("after:" + node.value) // 1
        }
        println("after:" + node.value) // 2
    }
    println("after:" + node.value) // 3
}
```

e.g. [递归反向打印字符串](leetcode.md)

## 2. 类的成员变量什么都可以干

类的成员变量：
- 代替函数参数中传递不变的参数
- 代替返回值
### 2.1. 传递不变的参数

```java
public class Main{
    public static void main(){
        str = new String("abc");
        f(0, str);
    }

    // str
    public static void f(int n, String str) {
        if (n == str.length()) {
            return;
        }
        f(n + 1, str);
        System.out.println(str.charAt(n));
    }
}
```

```java
public class Main{
    // 类的成员变量
    String str;

    public static void main(){
        str = new String("abc");
        f(0);
    }

    public static void f(int n) {
        if (n == str.length()) {
            return;
        }
        f(n + 1);
        System.out.println(str.charAt(n));
    }
}
```
### 2.2. 返回值

返回值天生就是倒着的：位于递归后面————尾递归`return f()` 即`int a = f(); return a`

本轮的返回值，和本轮中调用下一轮递归的返回值有关。所以设计边界条件，要考虑其返回值的意义。

反转链表的递归: 返回最后一个节点的位置，层层向上传递最后一个

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 两个都是不适合递归的特例
        if(head == null || head.next == null){
            return head;
        }
        return f(head);
    }

    public ListNode f(ListNode head){
        // 返回最后一个节点的位置
        if(head.next == null){
            return head;
        }
        ListNode last = f(head.next);
        head.next.next = head;
        head.next = null;
        return last;     // 层层向上传递最后一个
    }
}
```
```java
class Solution {
    // 类的成员变量
    ListNode last;
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        f(head);
        return last;
    }

    public void f(ListNode head){
        if(head.next == null){
            last = head;
            return;
        }
        f(head.next);
        head.next.next = head;
        head.next = null;
    }
}
```
## 3. 循环变递归

把最外层的循环拆出来。

`for(int i = 0 ; i < 10; i++)`
- `if(i>=10)`就是临界条件
- `recursion(..., 0)`->`recursion(..., i + 1)`

`while(i<=j), int i = 0, int j = 10, i++, j--`
- `if(i>j)`临界条件
- `recursion(..., i, j)` -> `recursion(..., i + 1, j - 1)`


## 4. 记忆数组

两种方式：一种在递归外面填充边界条件，另一种在递归内作为边界条件填充数组。

记忆数组的递归不用特别调用，正常就行。

这玩意也可以用动态规划来做。

## 多路递归

for循环展开看

## 多路递归→回溯

1. 剪枝
2. 回溯