- [1. 冒泡排序](#1-冒泡排序)
  - [1.1. 基础版 bubbleSortBasic](#11-基础版-bubblesortbasic)
  - [1.2. 改进版 bubbleSortX](#12-改进版-bubblesortx)
- [选择排序](#选择排序)
- [堆排序](#堆排序)
- [2. 插入排序](#2-插入排序)


---

```java
public void swap(int[] nums, int i, int j) {
    nums[i] = nums[i] ^ nums[j];
    nums[j] = nums[i] ^ nums[j];
    nums[i] = nums[i] ^ nums[j];
}
```
## 1. 冒泡排序

[bubbleSortBasic](./BubbleSort.java)

### 1.1. 基础版 bubbleSortBasic

* 每轮冒泡不断地比较**相邻**的两个元素，如果它们是逆序的，则交换它们的位置
* 下一轮冒泡，可以调整未排序的右边界，减少不必要比较

![alt text](../../../../../../../images/image-33.png)
```java
public int[] sortArray(int[] nums) {
    for (int i = nums.length - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            // 逆序
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1);
            }
        }
    }
    return nums;
}

j是实际元素的索引`a[j+1]`，i是j的边界。
           [ i 的范围   ]    // 因为 j < i
       [  j的范围   ]        // 因为 a[j+1]
index: 0   1   2   3   4
```
```java
public int[] sortArray(int[] nums) {
    sort(nums, nums.length - 1);
    return nums;
}

public void sort(int[] nums, int i) {
    if (i <= 0) {
        return;
    }
    for (int j = 0; j < i; j++) {
        if (nums[j] > nums[j + 1]) {
            swap(nums, j, j + 1);
        }
    }
    sort(nums, i - 1);
}
```
### 1.2. 改进版 bubbleSortX

- 用`x`记录最后一次交换的位置 `j`，最后一次交换 j 处是待排序数组的end索引（右边是有序的，j及其左是待排）。
- 让下一轮的 `i = x`。

![alt text](../../../../../../../images/image-34.png)
```java
public int[] sortArray(int[] nums) {
    for(int i = nums.length - 1; i > 0;){
        int x = 0;
        for(int j = 0 ; j < i; j++){
            if(nums[j] > nums[j+1]){
                swap(nums, j , j+1);
                x = j;
            }
        }
        i = x;
    }
    return nums;
}
```
```java
public int[] sortArray(int[] nums) {
    sort(nums, nums.length - 1);
    return nums;
}

public void sort(int[] nums, int i) {
    if (i <= 0) {
        return;
    }
    int x = 0;
    for (int j = 0; j < i; j++) {
        if (nums[j] > nums[j + 1]) {
            swap(nums, j, j + 1);
            x = j;
        }
    }
    sort(nums, x);
}
```
## 选择排序

每一轮选择，找出最大（最小）的元素，并把它交换到合适的位置

- 默认最大值从数组最后一个元素开始。（优化：最后一轮只剩一个元素可以不比较，它之前没有元素了）
- 比较它和它前面的元素。
- 将最大的元素放在它的位置上。（优化：如果是本身，那么不用交换）


![alt text](../../../../../../../images/image-35.png)


```java
public int[] sortArray(int[] nums) {
    // 默认最大元素的索引是i
    for(int i = nums.length - 1; i > 1 ; i--){
        int max = i;
        // 它之前的元素
        for(int j = 0 ; j < i; j++){
            if(nums[j] > nums[max]){
                max = j;
            }
        }
        if(max != i){
            swap(nums, i, max);
        }
    }
    return nums;
}
```
## 堆排序

1. 建大顶堆
2. 出堆顶直到剩一个。
```java
public int[] sortArray(int[] nums) {
    // 1. 建大顶堆
    int size = nums.length;
    buildHeap(nums, size);

    // 2. 出堆顶直到剩一个。
    for (int i = size - 1; i >= 1; i--) {
        // 交换堆顶和最后一个元素
        swap(nums, 0, i);
        // 重新下潜堆顶，i=size-1，刚好是新堆的大小
        down(nums, 0, i);
    }
    return nums;
}

public void buildHeap(int[] nums, int size) {
    // 从最后一个非叶子结点往堆顶，下潜
    for (int i = size / 2 - 1; i >= 0; i--) {
        down(nums, i, size);
    }
}

// 递归
// public void down(int[] nums, int parent, int size) {
//     int left = parent * 2 + 1;
//     int right = left + 1;
//     int max = parent;
//     // nums[left] > nums[max]: 是和max比
//     if (left < size && nums[left] > nums[max]) {
//         max = left;
//     }
//     if (right < size && nums[right] > nums[max]) {
//         max = right;
//     }
//     // 找到了更大的孩子
//     if (max != parent) {
//         swap(nums, max, parent);
//         down(nums, max, size);
//     }
// }

// 循环
public void down(int[] nums, int parent, int size) {
    while (true) {
        int left = parent * 2 + 1;
        int right = left + 1;
        int max = parent;
        if (left < size && nums[left] > nums[max]) {
            max = left;
        }
        if (right < size && nums[right] > nums[max]) {
            max = right;
        }
        if (max != parent) {
            swap(nums, max, parent);
            parent = max;
        } else {
            break;
        }
    }
}
```

## 2. 插入排序

- 将数组分为已排序部分和未排序部分：`[0 .. low-1]`  `[low .. a.length-1]`(优化：第一个不用排：low=1开始)
- 每次从未排序区域取出low下标的元素, 插入到已排序区域
- 插入到已排序区域：从low倒着往前，检查 low 左边的元素 `int i = low - 1;`，如果左边大于low所在的元素 `a[i] > a[low]`，就右移数组 `a[i+1] = a[i]`

```java
public int[] sortArray(int[] nums) {
    for (int low = 1; low < nums.length; low++) {
        // 因为会覆盖 low下标的元素，所以要保存到临时变量
        int t = nums[low];
        int i = low - 1;
        while (i >= 0 && nums[i] > t) { // >= 就是不稳定了
            nums[i + 1] = nums[i];
            i--;
        }
        // 刚好左边直接不满足，那么就是原位置不插 i+1= low-1+1=low
        if (i != low - 1) {
            nums[i + 1] = t;    // 当前是不符合的位置 nums[i] <= t，所以插入到下一个位置
        }
    }
    return nums;
}
```
```java
/*
    *  比上面赋值次数更多
    */
public static void insertSortSwap(int[] a){
    for (int low = 1; low < a.length; low++) {
        int i = low - 1;    // 遍历检查 low 左边的
        // 如果左边大于的就右移数组, a[low]就是初始的a[i+1]
        while (i >= 0 && a[i] > a[i+1]) {
            // 直接交换
            int t = a[i];
            a[i] = a[i+1];
            a[i+1] = t;
            i--;
        }
    }
}

public static void insertSortRecursion(int[] a) {
    recursion(a, 1);
}

public static void recursion(int[] a, int low) {
    if (low >= a.length) {
        return;
    }
    int l = a[low];
    int i = low - 1;
    while (i >= 0 && a[i] > l) {
        a[i + 1] = a[i];
        i--;
    }
    if (i != low - 1) {
        a[i + 1] = l;
    }
    recursion(a, low + 1);
}
```