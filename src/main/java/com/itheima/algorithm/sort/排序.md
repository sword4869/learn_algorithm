- [1. 冒泡排序](#1-冒泡排序)
  - [1.1. 基础版 bubbleSortBasic](#11-基础版-bubblesortbasic)
  - [1.2. 改进版 bubbleSortX](#12-改进版-bubblesortx)
- [2. 插入排序](#2-插入排序)


---

## 1. 冒泡排序

### 1.1. 基础版 bubbleSortBasic
```
value: 4, 5, 3, 2, 1
index: 0  1  2  3  4

第一轮：(0,1), (1,2), (2,3), (3,4)  索引4是最大值，已排序
第二轮：(0,1), (1,2), (2,3) 索引3是次大值，已排序
第三轮：(0,1), (1,2)
第四轮：(0,1)
```

```java
for (int i = a.length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {


           [ i 的范围   ]    // 因为 j < i
       [  j的范围   ]        // 因为 a[j+1]
index: 0   1   2   3   4
```

核心是关注 `a[j]`。

看第二层循环：交换`a[j]`和`a[j+1]`：j 从 0 开始，最大是 length - 2处。
- 平时遍历数组是最后一个元素索引的`j = length -1`的`for(int j = 0; j < length; j++)`，那么现在就是`j = length -2`的`j < length - 1`。那么传递到外层循环，就是`i = length - 1`
- 最后一轮是 `a[0]`和 `a[1]`比较，那么内层循环就是`for(int j = 0; j < 1; ...)`，传递到外层就是`i = 1`的`for (...; i > 0;... )`

### 1.2. 改进版 bubbleSortX

- 用`x`记录最后一次交换的位置 `j`，最后一次交换 j 处是边界，右边是有序的，j及其左是待排。
- 每轮开始，`i` 及其左的元素是待排
- 那么可以让下一轮的 `i = x`。

```
value: 3   4   2   6   5

                       i        // 循环开始，i 及其左的元素是待排
                   x            // 最后一次交换 j 处是边界，右边是有序的，j及其左是待排。
                   j
value: 3   2   4   5   6        // 循环结束，a[i]是当前轮的局部最大值。

下一轮
                   i
value: 3   2   4   5   6

                   i
               j
       x           
value: 2   3   4   5   6
```

## 2. 插入排序

- `low`：low及其右边的元素是待排序，从第二个元素开始。
- 遍历检查 low 左边的元素 `int i = low - 1;`，如果左边大于low所在的元素 `a[i] > a[low]`，就右移数组 `a[i+1] = a[i]`