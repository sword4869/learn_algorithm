- [1. 冒泡排序](#1-冒泡排序)
  - [1.1. 基础版 bubbleSortBasic](#11-基础版-bubblesortbasic)
  - [1.2. 改进版 bubbleSortX](#12-改进版-bubblesortx)
- [2. 插入排序](#2-插入排序)


---

## 1. 冒泡排序

[bubbleSortBasic](./BubbleSort.java)

### 1.1. 基础版 bubbleSortBasic

* 每轮冒泡不断地比较**相邻**的两个元素，如果它们是逆序的，则交换它们的位置
* 下一轮冒泡，可以调整未排序的右边界，减少不必要比较

j是实际元素的索引`a[j+1]`，i是j的边界。
```java
for (int i = a.length - 1; i > 0; i--) {
    for (int j = 0; j < i; j++) {


           [ i 的范围   ]    // 因为 j < i
       [  j的范围   ]        // 因为 a[j+1]
index: 0   1   2   3   4
```

```
value: 4, 5, 3, 2, 1
index: 0  1  2  3  4

第一轮：(0,1), (1,2), (2,3), (3,4)  索引4是最大值，已排序
第二轮：(0,1), (1,2), (2,3) 索引3是次大值，已排序
第三轮：(0,1), (1,2)
第四轮：(0,1)
```

### 1.2. 改进版 bubbleSortX

- 用`x`记录最后一次交换的位置 `j`，最后一次交换 j 处是边界，右边是有序的，j及其左是待排。
- 每轮开始，`i` 及其左的元素是待排
- 那么可以让下一轮的 `i = x`。

```
value: 3   4   2   6   5

                       i        // 循环开始，i 及其左的元素是待排
                   x            // 最后一次交换 j 处是边界，右边是有序的，j及其左是待排。
                   j
value: 3   2   4   5   6        // 循环结束，a[i]是当前轮的局部最大值。

下一轮
                   i
value: 3   2   4   5   6

                   i
               j
       x           
value: 2   3   4   5   6
```

## 2. 插入排序

- `low`：low及其右边的元素是待排序，从第二个元素开始。
- 遍历检查 low 左边的元素 `int i = low - 1;`，如果左边大于low所在的元素 `a[i] > a[low]`，就右移数组 `a[i+1] = a[i]`