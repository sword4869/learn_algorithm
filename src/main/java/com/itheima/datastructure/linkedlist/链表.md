可以分类为

* 单向链表：每个元素只知道其下一个元素是谁
* 双向链表：每个元素知道其上一个元素和下一个元素
* 循环链表：通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head
  * 有两个哨兵
  * 有一个哨兵

## 链表的性能

> 性能

**随机访问性能**

根据 index 查找，时间复杂度 $O(n)$

**插入或删除性能**：花在查找节点上

* 起始位置：$O(1)$
* 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$
* 中间位置：$O(n)$

## 哨兵

哨兵（Sentinel）/哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断。
- 在增加`insert(index, value)`和删除`remove(index)`操作时，我们需要找到当前位置的前一个结点 `findNode(index - 1)`，从而根据index 查找结点就要面临 index = -1 的情况。这时，`findNode()`返回哨兵结点就不用特别处理 index = -1了。
- 增加最后一个节点`addLast(value)`，需要找到最后一个结点`findLast()`，如果有哨兵结点（因为有next属性），那么操作就不用判断空链表。

双向循环链表的单双哨兵：
- 初始化不一样：一个哨兵两个指针和两个哨兵四个指针。
- `findNode()`不一样：单哨兵需要特别处理 index = -1，因为 for 循环的退出条件哨兵表示直接退出了。