## 链表的性能

> 性能

**随机访问性能**

根据 index 查找，时间复杂度 $O(n)$

**插入或删除性能**：花在查找节点上

* 起始位置：$O(1)$
* 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$
* 中间位置：$O(n)$

## 哨兵

哨兵（Sentinel）/哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断。
- 在增加`insert(index, value)`和删除`remove(index)`操作时，我们需要找到当前位置的前一个结点 `findNode(index - 1)`，从而根据index 查找结点就要面临 index = -1 的情况。这时，`findNode()`返回哨兵结点就不用特别处理 index = -1了。
- 增加最后一个节点`addLast(value)`，需要找到最后一个结点`findLast()`，如果有哨兵结点（因为有next属性），那么操作就不用判断空链表。

双向循环链表的单双哨兵：
- 初始化不一样：一个哨兵两个指针和两个哨兵四个指针。
- `findNode()`不一样：单哨兵需要特别处理 index = -1，因为 for 循环的退出条件哨兵表示直接退出了。


## 双指针
- 快慢指针：同一处开始，sentinel或head
- pre cur：pre从sentinel，cur从head

## 快慢指针

走多：`fast=fast.next`
1. [获取倒n](leetcode/获取倒n.md)：
   
   从哨兵开始还是从head开始都一样，因为拉开差距的是for，用了哨兵只是多走一次while.
2. [删除倒n](leetcode/19删除倒n.md)
   
   那么就要获取前一个节点（加入哨兵，for中`n+1`拉多一步找到前一个节点`）


走快：`fast=fast.next.next`
1. [获取中间](leetcode/876链表的中间结点.md)：
   
   倒数第一及后，`fast != null && fast.next != null`；倒数第二及后，`fast.next != null && fast.next.next != null`

   从head开始：不能是倒数第二及后，则**中间及中间偏左**。

   从head开始：不能是倒数第一及后，则**中间及中间偏右**。

   从哨兵开始：不能是倒数第一及后，则中间及中间偏左。相当于多了一个节点，中间及中间偏右→中间偏左及中间。

   PS：我们可以通过判断循环结束后的`fast/fast.next`来确定链表是奇数还是偶数。

## pre cur

1. 反转链表
2. 根据val移除链表元素、删除排序重复

## 题

- 反转链表 206：pre cur、新链表头插法、递归
- 根据值删除节点 203：pre cur、递归
- 删除倒数节点19
- 有序链表去重82、83：
- 合并有序链表21、23：数组排序、各链表指针
- 查找链表中间节点876
- 判断回文链表234
- 检测链表是否有环141
- 检测环的入口142
- 删除指定节点237
- 相交链表160

