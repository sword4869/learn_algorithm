## O(n),O(1)解

- 通过快慢指针找到中间和中间偏右的节点。
- 在快慢指针中，得到反转的前半部分链表p
- 让slow是中间偏右。
- 循环，一一比较p链表和slow链表。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode p = null; // 反转链表的头节点
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            // 反转
            ListNode next = slow.next;
            slow.next = p;
            p = slow;

            slow = next; // p右边是slow，slow是中间和中间偏右
        }

        if (fast != null) { // 中间, fast.next == null还得判断fast存在
            slow = slow.next;
        }

        while (slow != null) {
            if (slow.val != p.val) {
                return false;
            }
            slow = slow.next;
            p = p.next;
        }
        return true;
    }
}
```