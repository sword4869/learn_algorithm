- [1. 二分查找](#1-二分查找)
  - [1.1. （重要）ij都查](#11-重要ij都查)
  - [1.2. 查i不查j](#12-查i不查j)
  - [1.3. 查i不查j的平衡版](#13-查i不查j的平衡版)
  - [1.4. （重要）Leftmost 与 Rightmost](#14-重要leftmost-与-rightmost)
  - [1.5. （重要）Leftmost 与 Rightmost 的更有用版](#15-重要leftmost-与-rightmost-的更有用版)
- [2. 大O表示法](#2-大o表示法)

---
## 1. 二分查找

> 性能

- 前两种方法：

    时间复杂度

    * 最坏情况：$O(\log n)$
    * 最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$

    空间复杂度

    * 需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$ 


### 1.1. （重要）ij都查
```java
public static int binarySearchBasic(int[] a, int target) {
    int i = 0, j = a.length - 1;    
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;

    // 返回将会被按顺序插入的位置。
    //      return i;         直接写法
    //      return -(i + 1);  java底层写法
}
```

> 原理

i和j所在的元素都被查，则：
- 首尾元素都被查。`int i = 0, j = a.length - 1;`

    ```java
           i                 j
    value: 2 12 18 23 45 54 65
    ```
- 中间元素m：刚好就直接return；目标元素在中间元素m左边，则要移动右游标j；目标元素在中间元素m右边，则要移动左游标i。因为i和j所在的元素都被查，中间元素m又已经被比较过了，所以直接放到待查的新元素上 `j=m-1`,`i=m+1`。
- 临界条件：`where(i<=j)`，因为i和j所在的元素都被查，所以需要`==`

    ```
    //普通轮
    刚好要查12的情况，那么直接return
            m       
            i  j  
    value: 12  23 
    index:  3  4  

    //最后一轮
    刚好是12，那么直接return
    还不是，那么再经过i右移或j左移的操作，就该结束了
    
            m          
            i             i             i
            j          j             j
    value: 12    →    12                12
    index:  3          3                3
    ```
> 优化

1. `int m = (i+j)/2` → `int m = (i + j) >>> 1`
   
   两个大int的i、j相加会超int值，最终得到负数的m。

   而使用右移运算符则可以解决。

2. `return -1;` → 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
   
   - → `return i;`

        直接就是将会被按顺序插入的位置（插入到已有元素位置，则让当前元素后移；插入到数组外位置）。
   - → `return -(i + 1);`

        `插入位置 = 返回值+1后再取负`（其实就是还原i）。

        之所以用负数表示，是因为插入到负0和查找的正0的混淆，所以 + 1 再取负就是负1.
### 1.2. 查i不查j
```java
public static int binarySearchBasic(int[] a, int target) {
    int i = 0, j = a.length;    
    while (i < j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```
i所在的元素都被查，j则不查（j是右边界，左边的才会被查），则
- 首元素被查，尾元素的next边界。`int i = 0, j = a.length;`

    ```java
           i                    j
    value: 2 12 18 23 45 54 65
    ```
- 中间元素m：因为i所在的元素都被查，`i=m+1`；而j所在的不查，左边的才要被查，所以就放在已经比较过的中间元素m处，`j=m;`
- 临界条件：`while (i < j)`

    ```
    //最后一轮
    刚好要查12的情况，那么直接return
            m         
            i  j  
    value: 12  23 
    index:  3  4  

    还不是，则i右移或j移动到m处就这样，j所在的元素不查，那么就该退出 i<j 没有等于
            i  
            j  
    value: 12  
    index:  3  
    ```

### 1.3. 查i不查j的平衡版

```java
public static int binarySearchBalance(int[] a, int target) {
    int i = 0, j = a.length;
    while (1 < j - i) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m;
        } else {
            i = m;
        }
    }
    if (a[i] == target){
        return i;
    } else {
        return -1;
    }
}
```
> 原理

将判断相等的操作移动到外面，else就表示大于等于的情况（target在中间索引m的位置或右边），而i索引的位置要被查，就`i=m`；
```java
       i                    j
value: 2 12 18 23 45 54 65


// 退出条件：i和j相邻，确定了唯一一个元素。
            i   j
value: 2 12 18 23 45 54 65
```

> 性能

- 循环内的平均比较次数减少了（原本在target在中间索引右边的话，要比较两次；现在只比较一次）。
- 但是如果待查找元素恰好在数组中央，就不像原来只需要循环一次，而是要循环到只剩一个元素。
- 时间复杂度就没有最好最坏，都是查到只剩一个元素： $\Theta(log(n))$

### 1.4. （重要）Leftmost 与 Rightmost

返回的是最左侧的重复元素 / 返回的是最右侧的重复元素，没找到则返回-1.


```java
// leftmost：移动j向左
public static int binarySearchLeftmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    int candidate = -1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            candidate = m; // 记录候选位置
            j = m - 1;     // 继续向左
        }
    }
    return candidate;
}

// rightmost
public static int binarySearchRightmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    int candidate = -1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            candidate = m; // 记录候选位置
            i = m + 1;	   // 继续向右
        }
    }
    return candidate;
}
```
leftmost：本来中间索引m处找到了，但是还往左找（移动j向左 `j = m - 1`）
  
- 找18
    ```java
           m
           i   j  
    value: 18 18        找到了，记录
           
                i
            j
    value:      18 18 
    ```
- 找19
    ```java
           m
           i   j  
    value: 18 19 

                m
                i
                j
    value: 18  19       找到了，记录
    
                i
            j
    value: 18  19
    ```
    ```java
           i   m  j  
    value: 18 19 20     找到了，记录

            m
            i
            j
    value: 18 19  
    
               i
            j
    value: 18 19
    ```

### 1.5. （重要）Leftmost 与 Rightmost 的更有用版

对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值

1. 简化：不用记录`candidate`，则直接去掉`candidate = m; // 记录候选位置`这一行。剩下`i = m + 1;`可以合并到上面的if-else中。
2. return 返回的含义变化：leftmost 找到大于等于目标的最左元素 `return i`，rightmost 找到小于等于目标的最右元素 `return i-1`
```java
// leftmost：找到大于等于目标的最左元素
public static int binarySearchLeftmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target <= a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        }
    }
    return i;
}


找 18
        j  i
value: 12 18 18

找 15
        j  i
value: 12 18 18
```

```java
// rightmost：找到小于等于目标的最右元素
// PS: 如果返回i，那就是找到大于目标的最左元素
public static int binarySearchRightmost1(int[] a, int target) {
    int i = 0, j = a.length - 1;
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] <= target) {
            i = m + 1;
        }
    }
    return i - 1;
}

找 18
              j  i
value: 12 18 18 23

找 19
              j  i
value: 12 18 18 23
```

> 应用

![alt text](../images/image-25.png)


**求前任（predecessor）**：`leftmost(target) - 1`，-1是前一个的索引

* 存在，`leftmost(4) - 1 = 1`，前任 $a_1 = 2$
* 不存在，`leftmost(3) - 1 = 1`，前任 $a_1 = 2$

**求后任（successor）**：`rightmost(target) + 1`

* 存在，`rightmost(4) + 1 = 5`，后任 $a_5 = 7$
* 不存在，`rightmost(5) + 1 = 5`，后任 $a_5 = 7$


**求排名**：`leftmost(target) + 1`，+1是从 0-based 索引到 1-based 第几

* $target$ 存在，如：`leftmost(4)+1 = 3`
* $target$ 不存在，如：`leftmost(5)+1 = 6`


**范围查询**：

* 查询 $x \lt 4$，`[0，前任], 即[0, leftmost(4) - 1]`
* 查询 $x \leq 4$，`[0, rightmost(4)]`
* 查询 $x > 4$，`[后任，∞], 即[rightmost(4) + 1, \infty]`
* 查询 $x \geq 4$， `[leftmost(4) , \infty]`
* 查询 $4 \leq x \leq 7$，`[leftmost(4) , rightmost(7)]`
* 查询 $4 \lt x \lt 7$，`[rightmost(4)+1 , leftmost(7)-1]`

**求最近邻居**：

* 前任和后任距离更近者

## 2. 大O表示法

- 渐进上界：代表算法执行的最差情况
- 渐进下界 $\Omega(g(n))$：代表算法执行的最佳情况
- 渐进紧界$\Theta(g(n))$

大O表示法
* 表达式中相乘的常量，可以省略，如
  * $f(n) = 100*n^2$ 中的 $100$
* 多项式中数量规模更小（低次项）的表达式，如
  * $f(n)=n^2+n$ 中的 $n$
  * $f(n) = n^3 + n^2$ 中的 $n^2$
* 不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示
  * 例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) = \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略
* 类似的，对数的常数次幂可省略
  * 如：$log(n^c) = c * log(n)$ 


 按时间复杂度从低到高

* 黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化
* 绿色 $O(log(n))$，对数时间
* 蓝色 $O(n)$，线性时间，算法时间与数据规模成正比
* 橙色 $O(n*log(n))$，拟线性时间
* 红色 $O(n^2)$ 平方时间
* 黑色朝上 $O(2^n)$ 指数时间
* 没画出来的 $O(n!)$