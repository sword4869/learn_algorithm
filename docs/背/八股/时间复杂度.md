| 算法 |    最好    |    最坏    |    平均    |  空间   | 稳定 | 思想 |                  注意事项                  |      速度      |         优化          |
| :--: | :--------: | :--------: | :--------: | :-----: | :--: | :--: | :----------------------------------------: | :------------: | :-------------------: |
| 冒泡 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  O(1)   |  Y   | 比较 | 最好情况需要优化版本，而且是已经有序的数组 |      超时      | x记录最后一次交换位置 |
| 选择 |  O($n^2$)  |  O($n^2$)  |  O($n^2$)  |  O(1)   |  N   | 比较 |            交换次数一般少于冒泡            |      超时      |                       |
|  堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(1)   |  N   | 选择 |                                            |       快       |      非递归下潜       |
| 插入 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  O(1)   |  Y   | 比较 |          最好情况是已经有序的数组          |      巨慢      |   优化就是希尔排序    |
| 希尔 |  O(nlogn)  |  O($n^2$)  | O($nlogn$) |  O(1)   |  N   | 插入 |                                            |  比堆排序还快  |                       |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(n)   |  Y   | 分治 |          需要额外的O(n)的存储空间          | 比希尔排序还快 |                       |
| 快速 | O($nlogn$) |  O($n^2$)  | O($nlogn$) | O(logn) |  N   | 分治 |      需要把枢轴值随机化来缓解最坏情况      |      巨慢      |                       |

最坏、最好、平均一样：

​	选择

​	归并

​	堆



最坏情况下

​	n*logn：堆排序 归并排序



时间复杂度排序：

​	O(n)：位图排序（计数排序）它要求知道数据的取值范围

​	O(nlogn): 快速排序

​	O(n^2): 冒泡排序



稳定

​	冒泡排序、插入排序、归并排序、基数排序

不稳定

​	选择排序、希尔排序、快速排序、堆排序



---



二分查找的复杂度

​	O(log n)



平衡二叉树

​	查找，插入和删除性能都是 O(logN)



哈希表

​	查找、插入和删除性能都是 O(1)