[toc]

## 定义

贪心算法或贪婪算法，核心思想是

1. 将寻找最优解的问题分为**若干个子问题**
2. 每个子问题都采用贪心原则，选取当前最优解
3. 因为没有考虑所有可能，局部最优的堆叠**不一定**让最终解最优


贪在：“向前看，不回头”。比如，dijkstra的不看已经遍历过visited的节点。

常见问题及解答：

1. 贪心算法一定会找到最优解吗？
   答：不一定。贪心算法只保证在每一步选择中都是最优的，但并不能保证整个问题的最优解。例如，背包问题中的贪心算法可能会导致最后一个物品没有被装入背包。

2. 如何判断一个问题是否适合用贪心算法解决？
   答：一个问题如果可以用递归的方式分解成若干个子问题，且每个子问题都有明确的最优解(即局部最优),那么这个问题就可以用贪心算法解决。

3. 贪心算法的时间复杂度是多少？
   答：贪心算法的时间复杂度取决于问题的规模和具体实现。一般来说，对于规模较小的问题，贪心算法的时间复杂度可以达到O(nlogn)或O(n^2);对于规模较大的问题，可能需要O(n^3)或更高。

4. 什么情况，贪心可最优？

   **最优子结构**：原问题的最优解包含子问题的最优解

Dijkstra: 每次选择未遍历节点中最小距离的点，处理完它的邻居距离更新后，就不会再处理它，认为已经得到了这个节点的最小距离。

选择排序：每轮循环选择一个最小的。



- **硬币找零问题**：在某些硬币组合下，贪心算法总是可以得到最优解。
- **区间调度问题**：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。
- **分数背包问题**：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。
- **股票买卖问题**：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。
- **霍夫曼编码**：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。
- **Dijkstra 算法**：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。

## 分数背包

 [背包问题.md](背包问题.md) 


## 活动选择

活动选择：**选择最先结束的活动。**
- 先按照活动结束时间排序活动。
- 加入第一个活动，作为pre。遍历活动，当前活动的起始时间>=pre活动，才加入结果，并更新为pre。

```java
public static void select(Activity[] activities, int n) {
   List<Activity> result = new ArrayList<>();
   Activity prev = activities[0]; // 上次被选中的活动
   result.add(prev);
   for (int i = 1; i < n; i++) {
      Activity curr = activities[i]; // 正在处理的活动
      if (curr.start >= prev.finish) {
            result.add(curr);
            prev = curr;
      }
   }
   for (Activity activity : result) {
      System.out.println(activity);
   }
}
```

## 最大容量问题

 [11.盛最多水的容器.md](..\..\题\leetcode\11.盛最多水的容器.md) 

## 最大切分乘积问题

切分为和的因子，求因子相乘的最大值。

[15.4  最大切分乘积问题 - Hello 算法 (hello-algo.com)](https://www.hello-algo.com/chapter_greedy/max_product_cutting_problem/#2)

## 其他

 [1染色数组.md](..\..\..\题\笔试\美团\24秋\研7\1染色数组.md)  

[2最大美观值.md](..\..\..\题\笔试\美团\24秋\研7\2最大美观值.md) 
