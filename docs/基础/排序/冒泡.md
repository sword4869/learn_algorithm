# 冒泡排序


## 基础版

* 每轮冒泡不断地比较**相邻**的两个元素，如果它们是逆序的，则交换它们的位置
* 下一轮冒泡，可以调整未排序的右边界，减少不必要比较

![alt text](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202406201437403.png)
```java
// 912. 排序数组
public int[] sortArray(int[] nums) {
    for(int i = nums.length - 1; i >= 1; i--){
        for(int j = 0; j < i; j++){
            if(nums[j] > nums[j+1]){
                swap(nums, j, j+1);
            }
        }
    }
    return nums;
}
    
每轮待排序数组是[0...i]。其中第一轮是[0...n-1]，最后一轮是[0...1]，即for(int i = nums.length - 1; i >= 1; i--)
每轮比较j和j+1，则j的范围是[0...i-1],即 for(int j = 0; j < i; j++)
    
    
每轮待排序数组是[0...n-1], ..., [0...1]。
每轮比较j和j+1，则j的范围是[0...n-2], ..., [0]。
而j<i, 那么i的范围[n-1...1] 自减。
```
```java
// 递归
public int[] sortArray(int[] nums) {
    sort(nums, nums.length - 1);
    return nums;
}

public void sort(int[] nums, int i) {
    if (i < 1) {
        return;
    }
    for (int j = 0; j < i; j++) {
        if (nums[j] > nums[j + 1]) {
            swap(nums, j, j + 1);
        }
    }
    sort(nums, i - 1);
}
```
## 改进版：记录待排序数组边界

- 用`x`记录最后一次交换的位置 `j`，每轮结束 [0...j]是待排序部分, [j+1, n-1]是已排序（最后一次交换后，只是j+1一定是大的，j还可能比之前的小）
- 让下一轮的 `i = x`。

![alt text](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202406201437851.png)
```java
public int[] sortArray(int[] nums) {
    // 让下一轮的 `i = x`
    for(int i = nums.length - 1; i >= 1;){
        int x = 0;
        for(int j = 0 ; j < i; j++){
            if(nums[j] > nums[j+1]){
                swap(nums, j , j+1);
                x = j;
            }
        }
        i = x;
    }
    return nums;
}
```
```java
public int[] sortArray(int[] nums) {
    sort(nums, nums.length - 1);
    return nums;
}

public void sort(int[] nums, int i) {
    if (i < 1) {
        return;
    }
    int x = 0;
    for (int j = 0; j < i; j++) {
        if (nums[j] > nums[j + 1]) {
            swap(nums, j, j + 1);
            x = j;
        }
    }
    sort(nums, x);
}
```

# 时间复杂度

平均O(n logn)

最坏 O(n^2)

​	倒序数组，要n轮。