## 堆

**大顶堆堆顶最小，小顶堆堆顶最大**。
* 在大顶堆中，任意节点 C 与它的父节点 P 符合 $P.value \geq C.value$
* 而小顶堆中，任意节点 C 与它的父节点 P 符合 $P.value \leq C.value$

堆使用的是**完全二叉树**，特征：
* 如果从索引 0 开始存储节点数据
  * 节点 $i$ 的父节点为 $\lfloor((i-1)/2)\rfloor$
  * 节点 $i$ 的左子节点为 $2i+1$，右子节点为 $2i+2$
  * 非叶子节点范围为 $[0, size/2-1]$

满二叉树：
* 一棵满二叉树节点个数为 $2^h-1$，如下例中高度（层数） $h=3$ 节点数是 $2^3-1=7$

### 建堆

> 威廉姆斯算法

$n*\log n$。n次循环 * logn的插入排序

> Floyd

需要交换$2^h -h -1$次

其中 $2^h \approx n$，$h \approx \log_2{n}$，因此有时间复杂度 $O(n)$

**“从最后一个非叶子结点(size/2 - 1)往0索引，对每个节点下潜  ”**

### 下潜

1. parent自身和左右孩子left,right，选出最大值的索引为max
2. 如果max为孩子，那么交换parent和max，以max为parent递归再下潜。

### 出堆顶

1. 交换堆顶和最后一个元素
2. size--，表示删除元素。
3. 重新下潜堆顶

### 添加元素

1. 添加元素的位置为arr[size+1]，它的parent = (size-1)/2
2. 上浮：添加元素从child索引开始，比较新值和parent的值，如果parent处小，则将parent赋值给child，更新child索引为parent，直到大了或 child==0 才退出循环，将child处填上新值。

## 堆排序

1. 建大顶堆
2. 出堆顶直到剩一个。
3. 得到升序数组。 

# 题

 [295. 数据流的中位数.md](..\..\..\题\leetcode\295. 数据流的中位数.md) 