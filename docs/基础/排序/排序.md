```java
public void swap(int[] nums, int i, int j) {
    if(i == j) return;
    nums[i] = nums[i] ^ nums[j];
    nums[j] = nums[i] ^ nums[j];
    nums[i] = nums[i] ^ nums[j];
}

private void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

## 排序速记

冒泡：j和j+1比较，把最大的移到未排序的末尾。

选择：每轮从未排序选出最小的，放到已排序的末尾。

插入：每轮从未排序“随机”选一个，放到已排序中。



快速：两个哨兵。

归并：先划分两个mergeSort，再合并merge。

堆：先建大顶堆，再出堆。



桶：桶内排序，输出是把桶连起来就行。

计数：选出最大值，计数数组 m + 1。

基数：从低位到高位进行计数排序，基数作计数。

| 算法 |    最好    |    最坏    |    平均    |  空间   | 稳定 | 思想 |          注意事项          |      速度      |         优化          |
| :--: | :--------: | :--------: | :--------: | :-----: | :--: | :--: | :------------------------: | :------------: | :-------------------: |
| 冒泡 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   |  Y   |      |  最好需要优化 + 已经有序   |      超时      | x记录最后一次交换位置 |
| 选择 |  O($n^2$)  |  O($n^2$)  |  O($n^2$)  |  原地   |  N   |      |    交换次数一般少于冒泡    |      超时      |                       |
|  堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) |  原地   |  N   |      |                            |       快       |      非递归下潜       |
| 插入 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   |  Y   |      |       最好是已经有序       |      巨慢      |   优化就是希尔排序    |
| 希尔 |  O(nlogn)  |  O($n^2$)  | O($nlogn$) |  原地   |  N   |      |                            |  比堆排序还快  |                       |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(n)   |  Y   |      |       额外的O(n)空间       | 比希尔排序还快 |                       |
| 快速 | O($nlogn$) |  O($n^2$)  | O($nlogn$) | O(logn) |  N   |      | 枢轴值随机化来缓解最坏情况 |      巨慢      |                       |



## 图

![排序算法对比](https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png)

**稳定性**：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。

**自适应性**：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。

**是否基于比较**：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达 O(n) ，但其通用性相对较差。

## 稳定和不稳定

稳定

​	冒泡排序、插入排序；归并排序；桶计数基数排序

不稳定

​	选择排序（221）、希尔排序；快速排序（）、堆排序（左右乱）

## 时间复杂度

> 最坏、最好、平均一样：步骤是死的

​	选择O(n2)；归并O(nlogn)、堆O(nlogn)；计数O(n+m)、基数O(nk)



> 最好不一样

冒泡：最好情况是**优化版本** O(n)，当数组已排序，则一轮就结束。

插入：最好情况是 O(n)

> 最坏不一样

快速排序：最差时间复杂度 O(n2)，当数组中所有元素都相等、已正序、已倒序

桶排序：最差时间复杂度 O(n2) ，所有元素被分至同一个桶中

