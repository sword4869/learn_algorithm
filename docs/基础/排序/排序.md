## 排序速记

冒泡：j和j+1比较，把最大的移到未排序的末尾。

​	（1）两个for循环，内循环是比较。

​	（2）swap（j,j + 1），则j是[0，n-2]...[0, 0]，j<i，则 i从n-1开始，到1结束。

​	（3）优化：每轮记住最后一次交换的位置j为x，下一轮i=x。每轮结束[0, x]未排序、[x+1, n-1]已排序。

选择：每轮从未排序选出最小的，交换未排序的首位。

​	（1）两个for循环，内循环是从未排序中找。

​	（2）未排序部分为 [i, n-1]，且默认i是初始最小，则i属于 [0, n-2]。在未排序部分中找到元素最小的索引 k

​	（3）如果不原地 k=i，那么交换未排序的首位

插入：每轮从未排序“随机”选一个，插入到已排序中。

​	（1）for + while，内循环是待插入

​	（2）待插入部分是 [i, n-1]，i属于[1,n-1], 默认第一个已经不用插入，最后一个还要插入

​	（3）保持i处的变量base，将i左边元素右移，最后将base填入nums[j+1]。



快速：以哨兵值排序当前区间，左边的小于哨兵，右边的大于哨兵，再以哨兵位置递归左边子区间和右边子区间

​	（1）一个quickSort递归函数，一个partition根据哨兵排序和返回哨兵位置，

​	（2）quickSort的哨兵位置不参与下一次递归 `[i, p-1], [p+1, j]`，quickSort 只剩一个元素 i>=j 就退出，

​	（3）partion 的while循环 i < j 起码两个元素

​	（4）partition 先找到j给nums[i]，再找到 i 给 nums[j]。最后 i == j，赋值谁都行。

归并：先划分两个mergeSort，再合并merge。

​	（1）一个mergeSort递归函数，一个merge工具函数来合并数组。

​	（2）mergeSort 只有一个元素 i>=j 就退出

​	（3）mergeSort 的mid参与排序，因为它的中间位置不像哨兵的已经有序。

​	（4）merge的拷贝是数组合并剩下的，mergeSort的拷贝是覆盖原数组。

堆：先建大顶堆，再出堆。

​	（1）建大顶堆

​		从最后一个非叶子结点(size/2 - 1)往0索引，对每个节点下潜 

​	（2）出堆顶直到剩一个

​		交换：交换堆顶和最后一个元素

​		size--：表示删除元素

​		下潜：重新下潜堆顶

​	（3）得到升序数组。 



桶：桶内排序，输出是把桶连起来就行。

计数：选出最大值，计数数组 m + 1。

基数：从低位到高位进行计数排序，基数作计数。

| 算法 |    最好    |    最坏    |    平均    |  空间   | 稳定  | 思想 |          注意事项          |      速度      |         优化          |
| :--: | :--------: | :--------: | :--------: | :-----: | :---: | :--: | :------------------------: | :------------: | :-------------------: |
| 冒泡 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   | √ |      |  最好需要优化 + 已经有序   |      x      | x记录最后一次交换位置 |
| 选择 |  O($n^2$)  |  O($n^2$)  |  O($n^2$)  |  原地   |      |      |    交换次数一般少于冒泡    |      x      |                       |
| 插入 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   | √ |      |       最好是已经有序       |      巨慢      |   优化就是希尔排序    |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(n)   | √ |      |       额外的O(n)空间       | 快 |                       |
| 快速 | O($nlogn$) |  O($n^2$)  | O($nlogn$) | O(logn) |      |      | 枢轴值随机化来缓解最坏情况 |      巨慢      |                       |
|  堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) |  原地   |      |      |                            |       快       |      非递归下潜       |

归并和堆，都是 O($nlog n$)


## 图

![排序算法对比](https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png)

**稳定性**：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。

**自适应性**：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。

**是否基于比较**：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达 O(n) ，但其通用性相对较差。

## 稳定和不稳定

稳定

​	**冒泡排序、插入排序；归并排序**

不稳定

​	选择排序（441）

​	快速排序（441）

​	堆排序（左右乱）

## 时间复杂度

> 最坏、最好、平均一样：步骤是死的

​	选择O(n2)；归并O(nlogn)、堆O(nlogn)；计数O(n+m)、基数O(nk)



> 最好不一样

冒泡：最好情况是**优化版本** O(n)，当数组已排序，则一轮就结束。

插入：最好情况是 O(n)

> 最坏不一样

快速排序：最差时间复杂度 O(n2)，当数组中所有元素都相等、已正序、已倒序

桶排序：最差时间复杂度 O(n2) ，所有元素被分至同一个桶中

