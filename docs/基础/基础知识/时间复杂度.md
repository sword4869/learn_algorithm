[toc]

---
## 大O表示法

**讨论算法我们只关心最差**，最好和平均都是工程上用的

- 🚀渐进上界 $O(g(n))$ : 代表算法执行的最差情况
- 渐进下界 $\Omega(g(n))$ : 代表算法执行的最佳情况
- 渐进紧界 $\Theta(g(n))$ : 平均

大O表示法
* 表达式中相乘的常量，可以省略，如
  * $f(n) = 100*n^2$ 中的 $100$
* 多项式中数量规模更小（低次项）的表达式，如
  * $f(n)=n^2+n$ 中的 $n$
  * $f(n) = n^3 + n^2$ 中的 $n^2$
* 不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示
  * 例如：$log_2(n)$ 可以替换为 $log_{10}(n) = \log(n)$ , 因为 $log_2(n) = \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略
* 类似的，对数的常数次幂可省略
  * 如：$log(n^c) = c * log(n)$ 


 按时间复杂度从低到高

* 黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化
* 绿色 $O(log(n))$，对数时间
* 蓝色 $O(n)$，线性时间，算法时间与数据规模成正比
* 橙色 $O(n*log(n))$，拟线性时间
* 红色 $O(n^2)$ 平方时间
* 黑色朝上 $O(2^n)$ 指数时间
* 没画出来的 $O(n!)$



## 递归复杂度 Master theorem

> x不等于c时，T(n) = $O(n^{max(x,c)})$；相等时，T(n) = $O(n^c \log n)$

若有递归式
$$
T(n) = aT(\frac{n}{b}) + O(n^c)
$$
其中

* $a$ 是子问题个数
* $\dfrac{n}{b}$ 是子问题的规模，b是子问题缩小倍数。注意 $\dfrac{2}{3}N$ 规模对应的b是 $\dfrac{N}{\dfrac{3}{2}}$ 的 $\dfrac{3}{2}$
* $O(n^c)$ 是除递归外执行的计算



$\log_{b}{a} = \log_{子问题缩小倍数}{子问题个数}$

那么
$$
T(n) = 
\begin{cases}
\Theta(n^c) & f(n) = \Omega(n^c) 并且 \log_{b}{a} \lt c\\
\Theta(n^{\log_{b}{a}}\log{n}) & f(n) = \Theta(n^x)\\
\Theta(n^{\log_{b}{a}}) & f(n) = O(n^c) 并且 \log_{b}{a} \gt c
\end{cases}
$$



**例1**

$T(n) = 2T(\frac{n}{2}) + n^4$ 

- a=2, b=2, c=4

* 此时 $log_b a = 1 < 4$，由后者决定整个时间复杂度 $\Theta(n^4)$

**例2**

$T(n) = T(\frac{7n}{10}) + n$

* $a=1, b=\frac{10}{7}, c=1$
* 此时 $\log_b a = 0 < 1$，由后者决定整个时间复杂度 $\Theta(n)$

**例3**

$T(n) = 16T(\frac{n}{4}) + n^2$

* $a=16, b=4, c=2$
* 此时 $\log_ba=2 = c$，时间复杂度 $\Theta(n^2 \log{n})$



**例4**

$T(n) = 7T(\frac{n}{2}) + n^2$

* $a=7, b=2, c=2$
* 此时 $\log_2{7} =2.? > 2$，由前者决定整个时间复杂度 $\Theta(n^{\log_2{7}})$



**例5**

$T(n) = 2T(\frac{n}{4}) + \sqrt{n}$

* $a=2, b=4, c=0.5$
* 此时 $\log_4 2 = 0.5 = c$，时间复杂度 $\Theta(\sqrt{n}\ \log{n})$

<img src="https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202410090930835.png" alt="image-20241009093013717" style="zoom:67%;" />

## 常见估计

### i和j=i+1

```java
for (int i = 0; i < length - 1; i++) {
    for (int j = i + 1; j < length; j++) {
        if (a[i] > a[j])
            count++;
    }
}
```

就是组合，n-1个、n-2个……1个

那么就是 $\dfrac{(n-1+1)(n-1)}{2} = \dfrac{n(n-1)}{2}$，O(n)=n^2

