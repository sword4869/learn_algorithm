[toc]

[关于ASL(平均查找长度)的简单总结_平均查找长度asl-CSDN博客](https://blog.csdn.net/Ang_go/article/details/117302523)



# 二分查找

> 12个元素的排序数组进行二份查找，每个元素被查找的概率是想等的，则平均比较次数是？

$1*1+2*2+3*4+4*5=37$，故其次数为37/12



# 散列表

散列表（哈希表）中的冲突是指两个或多个键被映射到同一个哈希值（桶）的情况。处理冲突的方法主要有以下几种：

1. **开放地址法（Open Addressing）**：
   - **线性探测（Linear Probing）**：当冲突发生时，从冲突位置开始，按顺序检查下一个位置，直到找到一个空位置为止。
   
     公式为：$h'(k, i) = (h(k) + i) \% m $，其中 $h(k)$ 是哈希函数， $ i $ 是探测次数， $ m $ 是哈希表的大小。

   - **二次探测（Quadratic Probing）**：在发生冲突时，按二次方的步长进行探测。
   
     公式为：$ h'(k, i) = (h(k) + c_1 \cdot i + c_2 \cdot i^2) \% m $，其中 $ c_1 $ 和 $ c_2 $ 是常数。
   
   - **双重哈希（Double Hashing）**：使用两个哈希函数 $ h_1(k) $ 和 $ h_2(k) $。当冲突发生时，使用第二个哈希函数确定步长。
   
     公式为：$ h'(k, i) = (h_1(k) + i \cdot h_2(k)) \% m $。
   
2. **链地址法（Chaining）**：每个桶中不仅存储一个元素，而是存储一个链表或其他数据结构（如平衡二叉树或红黑树）以存储所有哈希到同一个值的元素。当发生冲突时，新元素被插入到链表的表头或表尾。

3. **再哈希法（Rehashing）**：当哈希表中的负载因子（已使用的桶数与总桶数的比值）超过某个阈值时，重新构建一个更大的哈希表，并将所有元素重新哈希到新的哈希表中。这种方法可以减少冲突的概率。



采⽤**开放定址法**处理散列表的冲突时，其平均查找⻓度【⾼于】**链接法**处理冲突

​	[线性探测法 - loserQiu - 博客园 (cnblogs.com)](https://www.cnblogs.com/longerQiu/p/11703441.html)

​		成功查找率：探测几次

​		失败查找率：找空位，空位只在 MOD7的范围内，超了会像循环数组从头找。



