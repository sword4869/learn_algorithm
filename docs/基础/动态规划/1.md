动态规划：递推 + 记忆。它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算





动态规划和递归的区别：

​	递归，**“从顶至底”**。

​		我们从原问题开始，递归地分解为较小子问题，直至解已知的最小子问题。之后，通过回溯逐层收集子问题的解，构建出原问题的解。

​		子问题中包含更小的重叠子问题，子子孙孙无穷尽也。绝大部分计算资源都浪费在这些重叠的子问题上。

​	递归+记忆，还是**“从顶至底”**

​	动态规划（递推+记忆），**“从底至顶”**。从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。只需使用循环迭代实现，无须使用递归。





动态规划和递归的联系：

​	最小子问题对应的状态。动态规划是初始状态，递归是边界条件。

​	递推公式 dp[i]=dp[i−1]+dp[i−2] 。动态规划是状态转移方程，递归是分解公式。





动态规划的空间优化：**“滚动变量”或“滚动数组”**。

​	由于 dp[i] 只与 dp[i−1] 和 dp[i−2] 有关，因此我们无须使用一个数组 `dp` 来存储所有子问题的解，而只需两个变量滚动前进即可。





上楼梯：

- 最大方案数量： `dp[i] = dp[i−1]+dp[i−2]`

- 最小代价：`dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];`

- 但不能连续两轮跳 1 阶的最大方案数量：`dp[n] = dp[n, 1] + dp[n, 2]`

  `dp[i, j]`表示上一次从i-j阶跳了j阶到了当前i阶。

  ![image-20240811163547226](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202408111635290.png)



动态规划or递归

在此基础上，动态规划问题还有一些判断的“加分项”。

- 问题包含**最大（小）或最多（少）**等最优化描述。
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在**递推关系**。

相应地，也存在一些“减分项”。

- 问题的目标是**找出所有可能的解决方案**，而不是找出最优解。
- 问题描述中有明显的**排列组合**的特征，需要返回**具体的多个方案**。





思路：

​	先子问题分解，从顶至底

​	按照“暴力搜索 → 记忆化搜索 → 动态规划”的顺序实现更加符合思维习惯。

