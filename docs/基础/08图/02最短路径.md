[toc]

## 最短路径问题的分类

- **无权最短路径问题**：直接用 BFS DFS 求解就行了。

- **带权最短路径问题**
  - 单源
    - Dijkstra（单源）：贪心，**处理所有顶点**，但不处理所有边。**不能处理负边**。
    - Bellman-Ford（单源）：**处理所有边**。**能处理负边，但不能处理负环**。
  - 多源
    - Floyd（多源）：处理所有顶点，嵌套。**能处理负边，但不能处理负环**。


> 选择：

无负权边：Dijkstra、Bellman-ford、Floyd

负权边：Bellman-ford、Floyd

检测负环：只有Bellman-Ford。

## Dijkstra

vis + dist

1. 为每个节点创建两个属性：访问和距离
   - 访问 vis：将节点分为「未遍历节点」和「已遍历节点」，一开始所有节点都未访问。
   - 距离 dist：起始节点到各节点的距离。起始节点自身的距离是0，其他都是INF
2. 选择 **未访问且距离最小** 的节点作为当前节点（所以N个节点N轮）：
   - 松弛操作，**更新未访问过的相邻节点的距离**：`dist[i] = min(dist[i], dist[cur] + w[cur][i])`
   - 标记当前节点为已访问



 [743. 网络延迟时间.md](..\..\题\leetcode\743. 网络延迟时间.md) 


## bellman-ford

edges + dist
1. 只需要每个节点添加dist：起始节点的距离是0，其他都是INF
2. 遍历每条边，松弛操作：`dist[to] = Math.min(dist[to], dist[from] + weight)`
3. n个节点n - 1轮。

PS: 遍历每条边，只要全部遍历就行，没有特定顺序。哪怕每轮都打乱也行。



检测负环，就是再来一轮，如果还能更小，说明有负环。但是不知道具体位置。



![alt text](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202406221614087.png)
* Dijkstra贪心，出问题是因为认为本次已经找到了该顶点的最短路径，下次不会再处理它（cur.visited = true）。所有负边存在时，就不会再考虑它。
* 与之对比，Bellman-Ford 并没有考虑局部距离最小的顶点，而是每次都处理所有边，所以不会出错，当然效率不如 Dijkstra


## floyd
基于w的二维dist 
1. 直接在邻接矩阵的基础上造二维dist：自身的距离是0，有链接是权重，不连接是INF
2. 遍历每个源节点和目标节点，松弛操作`dist[i][j] = Math.min(dist[i][j], dist[i][p] + dist[p][j])`
3. 重复n轮，每个节点都被当做中继节点。

![alt text](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202503052026037.png)

