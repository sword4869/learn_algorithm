[toc]

## 排序速记

冒泡：**j和j+1比较**，把最大的移到未排序的末尾。

​	（1）两个for循环。

​	（2）内循环是从0开始swap（j,j + 1），则j是[0，n-2]...[0, 0]，j<i，则外循环的 i从n-1开始，到1结束。

​	（3）优化：每轮记住最后一次交换的位置j为x，下一轮i=x。每轮结束[0, x]未排序、[x+1, n-1]已排序。

选择：【已排序】【未排序】**每轮从未排序选出最小的，交换未排序的首位**。

​	（1）两个for循环。

​	（2）内循环在未排序部分为 **[i, n-1]**中找，**外循环控制未排序部分的起始位置**，**则i属于 [0, n-1]**。在未排序部分中找到元素最小的索引 min.

​	（3）如果不原地 min=i，那么交换未排序的首位

插入：【已排序】【未排序】**每轮从未排序选第一个，插入到已排序中**。

​	（1）for + while

​	（2）同样未排序部分为 **[i, n-1]**中找，**外循环控制未排序部分的起始位置**，**则i属于 [0, n-1]**

​	（3）while：将未排序的首个元素i前移，找到已排序中大于它的元素，就将其右移，最后将i填入nums[j+1]。



快速：以哨兵值排序当前区间，左边的小于哨兵，右边的大于哨兵

​	（1）一个quickSort递归函数，传入左边子区间和右边子区间 [l, r]

​	（2）默认第一个是哨兵，左右双指针ij排序，先找右边的j再找左边的i，最后 i == j，填充哨兵。

​	（3）下一次递归 `[l, i-1], [i+1, r]`，哨兵i不参与。

归并：m=l+r>>>1, 先划分两个mergeSort `[l, m], [m+1, r]`，再合并merge。

​	（1）一个mergeSort递归函数，一个merge工具函数来合并数组。

​	（2）mergeSort 的mid参与排序，因为它的中间位置不像哨兵的已经有序。

​	（4）merge中向拷贝数组合并剩下的，再拷贝临时数组覆盖原数组。

堆：先建大顶堆，再出堆。

​	（1）建大顶堆

​		从最后一个非叶子结点(size/2 - 1)往0索引，对每个节点下潜 

​	（2）出堆顶直到剩一个

​		交换：交换堆顶和最后一个元素

​		size--：表示删除元素

​		下潜：重新下潜堆顶





| 算法 |    最好    |    最坏    |    平均    |  空间   | 稳定  | 思想 |          注意事项          |      速度      |         优化          |
| :--: | :--------: | :--------: | :--------: | :-----: | :---: | :--: | :------------------------: | :------------: | :-------------------: |
| 冒泡 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   | √ |      |  最好需要优化 + 已经有序   |      x      | x记录最后一次交换位置 |
| 选择 |  O($n^2$)  |  O($n^2$)  |  O($n^2$)  |  原地   |      |      |    交换次数一般少于冒泡    |      x      |                       |
| 插入 |    O(n)    |  O($n^2$)  |  O($n^2$)  |  原地   | √ |      |       最好是已经有序       |      巨慢      |   优化就是希尔排序    |
| 归并 | O($nlogn$) | O($nlogn$) | O($nlogn$) |  O(n)   | √ |      |       额外的O(n)空间       | 快 |                       |
| 快速 | O($nlogn$) |  O($n^2$)  | O($nlogn$) | O(logn) |      |      | 枢轴值随机化来缓解最坏情况 |      巨慢      |                       |
|  堆  | O($nlogn$) | O($nlogn$) | O($nlogn$) |  原地   |      |      |                            |       快       |      非递归下潜       |

归并和堆，都是 O($nlog n$)


## 图

![排序算法对比](https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png)

**稳定性**：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。

**自适应性**：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。

**是否基于比较**：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达 O(n) ，但其通用性相对较差。

## 🚀稳定和不稳定

- 不稳定

  - **快速排序**（441）

  - **堆排序**（左右乱）
  - **选择排序**（441，前面的相同元素因交换而排到后面）

- 稳定：记住不稳定，剩下3个就是稳定

  - **冒泡排序**

  - **插入排序**

  - **归并排序**

## 🚀时间复杂度

- 最坏、最好、平均一样：步骤是死的

  - $O(n^2)$：选择

  - O(nlogn)：归并、堆

- 最好 O(n)：数组已排序
  - 冒泡（如果是**优化版本**，则一轮就结束）
  - 插入

- 最坏不一样 $O(n^2)$
  - 快速排序：当数组中所有元素都相等、已正序、已倒序

### 很多排序最优是nLogn的，有没有更优的？

如果是

- **数据类型是整数**，
- **范围较小**

计数排序、桶排序、基数排序，可以达到 O(n)

- 桶：桶内排序，输出是把桶连起来就行。
  - 最差时间复杂度 O(n2) ，所有元素被分至同一个桶中

- 计数：选出最大值，计数数组 m + 1。

- 基数：从低位到高位进行计数排序，基数作计数。

## 计算题

### 猜出排序

#### 指定结果

> 有字符序列（Q，H，C，Y，P，A，M，S，R，D，F，X），新序列（F，H，C，D，A，M，P，S，R，Y，Q，X）是下列哪个排序算法。
>
> 快速排序。确实只有一个M在应该存在的位置；

快速排序，哨兵。

冒泡排序，看末尾，而且每趟只动一个。

#### 指定排序

快速排序的哨兵，有些是首位，有些是随机。

> 排序算法中，将所有元素进行一遍处理的过程称为“趟”。下列序列中，不可能是快速排序第二趟排序结果的是D
>
> A 2,1,4,3,5,7,6,8
>
> B 1,4,2,5,3,7,6,8
>
> C 1,3,4,2,5,6,8,7
>
> D 2,1,3,5,4,6,8,7

快速排序如第一趟确定的值是**首尾元素**，则第二趟只能确定一个数；

如第一趟确定的是**中间元素**，则第二趟会确定两个元素。

![image-20240622232637827](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202406222326894.png)

## leetcode

### 归并排序

统计个数

​	[493. 翻转对.md](..\..\题\leetcode\493. 翻转对.md) ：分开。

​	[计算数组的小和.md](..\..\题\笔试\计算数组的小和.md) ：一起。

​	🚀[LCR 170. 交易逆序对的总数.md](..\..\题\leetcode\LCR 170. 交易逆序对的总数.md)：一起。当满足 `nums[i] > nums[j]`时，左子数组中的 i 右边的数一定大于`nums[j]`，就是逆序对的个数`count += m - p1 + 1;`

改造：

​	 [23. 合并 K 个升序链表.md](..\..\题\leetcode\23. 合并 K 个升序链表.md) ：

### 堆

[215. 数组中的第K个最大元素.md](..\..\题\leetcode\215. 数组中的第K个最大元素.md) : 

都是替换堆顶。

topK大的最优：维护小顶堆 nlogk

topK小的最优：维护大顶堆 nlogk

​	**堆顶元素是最大最小，但堆底部的左右顺序无法控制**。

​	拿topK大来说。所以如果大顶堆，堆顶是最大值，我们无法堆底的topk。所以只能用小顶堆，堆顶就是topk大。

​	拿topK小来说。所以如果小顶堆，堆顶是最小值，我们无法堆底的topk。所以只能用大顶堆，堆顶就是topk小。

​	从n个元素中查找最小的k个元素时，使用大顶堆的效率比使用小顶堆更高“。前者（维护k个元素的大顶堆）是 nlogk，后者（维护n个元素的小顶堆）是nlogn。



[295. 数据流的中位数.md](..\..\题\leetcode\295. 数据流的中位数.md)  

