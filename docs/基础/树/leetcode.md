[toc]

> 树的递归和dfs：
>
> - **思路**：递归从下往上，dfs从下往上。
> - **返回值**：
>   - 需要**返回值**的只能用递归做，**void dfs**做不了。
>   - 递归的返回值操作是在**递归函数调用后**（虽然听起来有点废话），这点不同于dfs。
>
> - 都可以操作全局变量，这个不算区别。
>
> 明显的例子，104 都可，而543必须递归。

## 相同的树

【模板】 [100. 相同的树.md](..\..\题\leetcode\100. 相同的树.md) ：dfs。给出两个树的结点，判断两棵树是否相同

[101.对称二叉树.md](..\..\题\leetcode\101.对称二叉树.md) 

[110. 平衡二叉树.md](..\..\题\leetcode\110. 平衡二叉树.md)：根据当前节点的左右子树的深度之差。

[226. 翻转二叉树.md](..\..\题\leetcode\226. 翻转二叉树.md)  

199. 二叉树的右视图 https://leetcode.cn/problems/binary-tree-right-side-view/solution/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/

## 树的深度：普通递归

> 因为 543 用到的是普通递归，void dfs解决不了

【递归模板】[104. 二叉树的最大深度.md](..\..\题\leetcode\104. 二叉树的最大深度.md)  ： 从 **根节点** 到最远叶子节点的最长路径上的节点数

🚀（只能递归）[543. 二叉树的直径.md](..\..\题\leetcode\543. 二叉树的直径.md) ：根据当前节点的左右子树的深度找最大。



（均可）[111. 二叉树的最小深度.md](..\..\题\leetcode\111. 二叉树的最小深度.md) ： min(左/右) + 1





## 数字和：dfs

【模板】[112. 路径总和.md](..\..\..\题\leetcode\112. 路径总和.md) ：dfs

[113. 路径总和 II.md](..\..\..\题\leetcode\113. 路径总和 II.md)

[129. 求根节点到叶节点数字之和.md](..\..\题\leetcode\129. 求根节点到叶节点数字之和.md)

 [1448. 统计二叉树中好节点的数目.md](..\..\题\leetcode\1448. 统计二叉树中好节点的数目.md) 

## 遍历

[103. 二叉树的锯齿形层序遍历.md](..\..\题\leetcode\103. 二叉树的锯齿形层序遍历.md) 



递归：

​	[104. 二叉树的最大深度.md](..\..\题\leetcode\104. 二叉树的最大深度.md)：简单。dfs 返回节点个数（子树的深度）：0 / max(左, 右) + 自身 1. 

​	🚀 [543. 二叉树的直径.md](..\..\题\leetcode\543. 二叉树的直径.md)：

​		dfs 返回的是 节点个数（子树的深度）

​		res 更新是直径，直径 = **左节点个数 + 右节点个数**。

​	🚀 [124. 二叉树中的最大路径和.md](..\..\题\leetcode\124. 二叉树中的最大路径和.md) 

​		dfs 返回的是 最大链和：保证一定非负。0 / max(max(左, 右) + 自 vall, 0).

​		res 更新是 **最大路径和 = 自身 val + 左节点的最大链和 + 右节点的最大链和**。



 [987. 二叉树的垂序遍历.md](..\..\题\leetcode\987. 二叉树的垂序遍历.md) ：dfs



## 二叉搜索树

 [98. 验证二叉搜索树.md](..\..\题\leetcode\98. 验证二叉搜索树.md) 

 [96. 不同的二叉搜索树.md](..\..\题\leetcode\96. 不同的二叉搜索树.md)  [95. 不同的二叉搜索树 II.md](..\..\题\leetcode\95. 不同的二叉搜索树 II.md) 
