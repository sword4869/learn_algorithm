[toc]

## 相同的树

【模板】 [100. 相同的树.md](..\..\题\leetcode\100. 相同的树.md) ：给出两个树的结点，判断两棵树是否相同

[101.对称二叉树.md](..\..\题\leetcode\101.对称二叉树.md) 

[226. 翻转二叉树.md](..\..\题\leetcode\226. 翻转二叉树.md)  





## 树的深度

【模板】[104. 二叉树的最大深度.md](..\..\题\leetcode\104. 二叉树的最大深度.md)  ： 从 **根节点** 到最远叶子节点的最长路径上的节点数

[543. 二叉树的直径.md](..\..\题\leetcode\543. 二叉树的直径.md) ：根据当前节点的左右子树的深度找最大。

[110. 平衡二叉树.md](..\..\题\leetcode\110. 平衡二叉树.md)：根据当前节点的左右子树的深度之差。

[111. 二叉树的最小深度.md](..\..\题\leetcode\111. 二叉树的最小深度.md) ： min(左/右) + 1





## 遍历

[103. 二叉树的锯齿形层序遍历.md](..\..\题\leetcode\103. 二叉树的锯齿形层序遍历.md) 



递归：

​	[104. 二叉树的最大深度.md](..\..\题\leetcode\104. 二叉树的最大深度.md)：简单。dfs 返回节点个数（子树的深度）：0 / max(左, 右) + 自身 1. 

​	🚀 [543. 二叉树的直径.md](..\..\题\leetcode\543. 二叉树的直径.md)：

​		dfs 返回的是 节点个数（子树的深度）

​		res 更新是直径，直径 = **左节点个数 + 右节点个数**。

​	🚀 [124. 二叉树中的最大路径和.md](..\..\题\leetcode\124. 二叉树中的最大路径和.md) 

​		dfs 返回的是 最大链和：保证一定非负。0 / max(max(左, 右) + 自 vall, 0).

​		res 更新是 **最大路径和 = 自身 val + 左节点的最大链和 + 右节点的最大链和**。

[112. 路径总和.md](..\..\..\题\leetcode\112. 路径总和.md) ：bfs，dfs

[113. 路径总和 II.md](..\..\..\题\leetcode\113. 路径总和 II.md) ：bfs，dfs



## 二叉搜索树

 [98. 验证二叉搜索树.md](..\..\题\leetcode\98. 验证二叉搜索树.md) 

 [96. 不同的二叉搜索树.md](..\..\题\leetcode\96. 不同的二叉搜索树.md)  [95. 不同的二叉搜索树 II.md](..\..\题\leetcode\95. 不同的二叉搜索树 II.md) 
