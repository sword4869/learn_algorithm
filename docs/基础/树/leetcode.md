[toc]

> 树的递归和dfs：
>
> - **思路**：递归从下往上，dfs从下往上。
> - **返回值**：
>   - 需要**返回值**的只能用递归做，**void dfs**做不了。
>   - 递归的返回值操作是在**递归函数调用后**（虽然听起来有点废话），这点不同于dfs。
>
> - 都可以操作全局变量，这个不算区别。
>
> 明显的例子，104 都可，而543必须递归。

## 相同的树：普通递归

【模板】 [100. 相同的树.md](..\..\题\leetcode\100. 相同的树.md) ：给出两个树的结点，判断两棵树是否相同

[101.对称二叉树.md](..\..\题\leetcode\101.对称二叉树.md) 

## 树的深度：普通递归

> 因为 543 用到的是普通递归，void dfs解决不了

【递归模板】[104. 二叉树的最大深度.md](..\..\题\leetcode\104. 二叉树的最大深度.md)  ： 从 **根节点** 到最远叶子节点的最长路径上的节点数

🚀（只能递归）[543. 二叉树的直径.md](..\..\题\leetcode\543. 二叉树的直径.md) ：根据当前节点的左右子树的深度找最大。

🚀（只能递归）[110. 平衡二叉树.md](..\..\题\leetcode\110. 平衡二叉树.md)：根据当前节点的左右子树的深度之差。



（均可）[111. 二叉树的最小深度.md](..\..\题\leetcode\111. 二叉树的最小深度.md) ： min(左/右) + 1

## 数字和：dfs

【模板】[112. 路径总和.md](..\..\..\题\leetcode\112. 路径总和.md) ：dfs

[113. 路径总和 II.md](..\..\..\题\leetcode\113. 路径总和 II.md)

[129. 求根节点到叶节点数字之和.md](..\..\题\leetcode\129. 求根节点到叶节点数字之和.md)

[1448. 统计二叉树中好节点的数目.md](..\..\题\leetcode\1448. 统计二叉树中好节点的数目.md)

🚀[124. 二叉树中的最大路径和.md](..\..\题\leetcode\124. 二叉树中的最大路径和.md) ：普通递归

## 其他

[226. 翻转二叉树.md](..\..\题\leetcode\226. 翻转二叉树.md): dfs 或 普通递归

## 遍历

[103. 二叉树的锯齿形层序遍历.md](..\..\题\leetcode\103. 二叉树的锯齿形层序遍历.md) 

 [199. 二叉树的右视图.md](..\..\题\leetcode\199. 二叉树的右视图.md) ：dfs，先dfs(right)再dfs(left)

 [987. 二叉树的垂序遍历.md](..\..\题\leetcode\987. 二叉树的垂序遍历.md) ：dfs

## 二叉搜索树

 [98. 验证二叉搜索树.md](..\..\题\leetcode\98. 验证二叉搜索树.md) 

 [96. 不同的二叉搜索树.md](..\..\题\leetcode\96. 不同的二叉搜索树.md)  [95. 不同的二叉搜索树 II.md](..\..\题\leetcode\95. 不同的二叉搜索树 II.md) 
