- [二分查找](#二分查找)
  - [ij都查](#ij都查)
  - [查i不查j](#查i不查j)
- [大O表示法](#大o表示法)

---
## 二分查找

### ij都查
```java
public static int binarySearchBasic(int[] a, int target) {
    int i = 0, j = a.length - 1;    
    while (i <= j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m - 1;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
    // return -(i + 1);
}
```

> 原理

i和j所在的元素都被查，则：
- 首尾元素都被查。`int i = 0, j = a.length - 1;`
- 中间元素m：刚好就直接return；目标元素在中间元素m左边，则要移动右游标j；目标元素在中间元素m右边，则要移动左游标i。因为i和j所在的元素都被查，中间元素m又已经被比较过了，所以直接放到待查的新元素上 `j=m-1`,`i=m+1`。
- 临界条件：`where(i<=j)`，因为i和j所在的元素都被查，所以需要`==`

    ```
    //普通轮
    刚好要查12的情况，那么直接return
            m       
            i  j  
    value: 12  23 
    index:  3  4  

    //最后一轮
    刚好是12，那么直接return
    还不是，那么再经过i右移或j左移的操作，就该结束了
    
            m          
            i             i             i
            j          j             j
    value: 12    →    12                12
    index:  3          3                3
    ```
> 优化

1. `int m = (i+j)/2` → `int m = (i + j) >>> 1`
   
   两个大int的i、j相加会超int值，最终得到负数的m。

   而使用右移运算符则可以解决。

2. `return -1;` → `return -(i + 1);`

    插入位置 = 返回值+1后再取负。插入到已有元素位置，则让当前元素后移；插入到数组外位置。

    之所以用负数表示，是因为插入到负0和查找的正0的混淆。
### 查i不查j
```java
public static int binarySearchBasic(int[] a, int target) {
    int i = 0, j = a.length;    
    while (i < j) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m;
        } else if (a[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```
i所在的元素都被查，j则不查（j是右边界，左边的才会被查），则
- 首元素被查，尾元素的next边界。`int i = 0, j = a.length;`
- 中间元素m：因为i所在的元素都被查，`i=m+1`；而j所在的不查，左边的才要被查，所以就放在已经比较过的中间元素m处，`j=m;`
- 临界条件：`while (i < j)`

    ```
    //最后一轮
    刚好要查12的情况，那么直接return
            m         
            i  j  
    value: 12  23 
    index:  3  4  

    还不是，则i右移或j移动到m处就这样，j所在的元素不查，那么就该退出 i<j 没有等于
            i  
            j  
    value: 12  
    index:  3  
    ```

> 性能

时间复杂度

* 最坏情况：$O(\log n)$
* 最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$

空间复杂度

* 需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$ 

## 大O表示法

- 渐进上界：代表算法执行的最差情况
- 渐进下界 $\Omega(g(n))$：代表算法执行的最佳情况
- 渐进紧界$\Theta(g(n))$

大O表示法
* 表达式中相乘的常量，可以省略，如
  * $f(n) = 100*n^2$ 中的 $100$
* 多项式中数量规模更小（低次项）的表达式，如
  * $f(n)=n^2+n$ 中的 $n$
  * $f(n) = n^3 + n^2$ 中的 $n^2$
* 不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示
  * 例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) = \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略
* 类似的，对数的常数次幂可省略
  * 如：$log(n^c) = c * log(n)$ 


 按时间复杂度从低到高

* 黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化
* 绿色 $O(log(n))$，对数时间
* 蓝色 $O(n)$，线性时间，算法时间与数据规模成正比
* 橙色 $O(n*log(n))$，拟线性时间
* 红色 $O(n^2)$ 平方时间
* 黑色朝上 $O(2^n)$ 指数时间
* 没画出来的 $O(n!)$