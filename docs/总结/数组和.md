## 560.和为K的子数组.md
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int sum = 0;
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            count += map.getOrDefault(sum-k, 0);
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return count;
    }
}
```

通过计算前缀和，我们可以将问题转化为求解两个前缀和之差等于k的情况。

> 前缀和

对于数组 $\textit{nums}$，定义它的前缀和 $\textit{pre}[0]=0$，$\textit{pre}[i+1] = \sum\limits_{j=0}^{i}\textit{nums}[j]$。

例如 $\textit{nums}=[1,2,1,2]$，对应的前缀和数组为 $pre=[0,1,3,4,6]$。

根据这个定义，有 $pre[i+1]=pre[i]+\textit{nums}[i]$。


> 前缀和之差

我们定义 $pre[i]$ 为 $[0...right] = [0...left-1][left...right]$ 里所有数的和，那么我们可以把子数组的元素和转换成两个前缀和的差，即

$$\displaystyle \sum_{j=\textit{left}}^{\textit{right}}\textit{nums}[j] = \textit{pre}[\textit{right}+1] - \textit{pre}[\textit{left}] = \sum\limits_{j=0}^{\textit{right}} \textit{nums}[j] - \sum\limits_{j=0}^{\textit{left}-1}\textit{nums}[j] $$

注：$pre[0]=0$ 表示一个空数组的元素和

> 哈希表

在这段代码中，使用了一个哈希表 map 来记录累加和出现的次数。这个哈希表的键是累加和，值是累加和出现的次数。

当我们遍历数组时，每次累加得到的和 sum 都会被记录在 map 中，并且会检查是否存在 sum - k 的键。

如果存在，表示从之前某个位置到当前位置的子数组和为 k。那么说明从上次 sum - k 出现到当前位置的子数组和为 k。因此，我们可以通过 map.get(sum - k) 来获取到符合条件的子数组的个数。

$$\textit{pre}[i]-\textit{pre}[j]==k$$

至于提前设置(0,1)是因为我们是如果相减结果是0的话，就说明，从头到当前位置的数组就是所求。但是由于代码的put是在count之后的，所以提前先把(0,1)设置好。

这样，通过遍历一次数组，我们可以统计出和为k的连续子数组的个数，并且时间复杂度为O(n)，其中n为数组的长度。

## 
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int maxPre = nums[0];
        for (int i = 0; i < nums.length; i++) {
            pre = Math.max(pre + nums[i], nums[i]);
            if (pre > maxPre)
                maxPre = pre;
        }
        return maxPre;
    }
}
```

> 前缀和解法

由于子数组的元素和等于两个前缀和的差，所以**将数组转化为前缀和数组**，问题就变成 121. 买卖股票的最佳时机 了。

[−2,1,−3,4,−1,2,1,−5,4] 👉 [0, −2, -1,−4, 0, −1, 1, 2, −3, 1]

本题子数组不能为空，相当于一定要交易一次。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int profit = Integer.MIN_VALUE;     // 最小值，则for中必买一次
        int minPreSum = 0;      // 最低价格。即前缀和中的第一个元素 0
        int preSum = 0;     
        for (int x : nums) {
            preSum += x; // 当前的前缀和，相当于股票今日价格
            profit = Math.max(profit, preSum - minPreSum); // 减去前缀和的最小值
            minPreSum = Math.min(minPreSum, preSum); // 维护前缀和的最小值
        }
        return profit;
    }
}
```