## 2. 大O表示法

- 渐进上界：代表算法执行的最差情况
- 渐进下界 $\Omega(g(n))$：代表算法执行的最佳情况
- 渐进紧界$\Theta(g(n))$

大O表示法
* 表达式中相乘的常量，可以省略，如
  * $f(n) = 100*n^2$ 中的 $100$
* 多项式中数量规模更小（低次项）的表达式，如
  * $f(n)=n^2+n$ 中的 $n$
  * $f(n) = n^3 + n^2$ 中的 $n^2$
* 不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示
  * 例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) = \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略
* 类似的，对数的常数次幂可省略
  * 如：$log(n^c) = c * log(n)$ 


 按时间复杂度从低到高

* 黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化
* 绿色 $O(log(n))$，对数时间
* 蓝色 $O(n)$，线性时间，算法时间与数据规模成正比
* 橙色 $O(n*log(n))$，拟线性时间
* 红色 $O(n^2)$ 平方时间
* 黑色朝上 $O(2^n)$ 指数时间
* 没画出来的 $O(n!)$

```
String a = String.format("%d", 12);     // 12
```
## contain 是否存在

contain + getIndex，而不是直接 return true/false.
```java
//判断id在集合中是否存在
public static boolean contains(ArrayList<Student> list, String id) {
    return getIndex(list,id) >= 0;
}

//通过id获取索引的方法
public static int getIndex(ArrayList<Student> list, String id){
    for (int i = 0; i < list.size(); i++) {
        Student stu = list.get(i);
        String sid = stu.getId();
        if(sid.equals(id)){
            return i;
        }
    }
    return -1;
}
```

## test

```java
assertIterableEquals(List.of(4, 3, 2, 1), list);

assertEquals(3, list.get(2));

assertThrows(IllegalArgumentException.class, () -> list.get(10));
assertThrows(IllegalArgumentException.class, list::removeFirst);
```